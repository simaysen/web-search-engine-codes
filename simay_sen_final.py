# -*- coding: utf-8 -*-
"""simay_sen_final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12t2tMn-FInrkLdAoyt1XDXCh8kLWVXQD

### **First Name:** **Simay**

### **Surname: Şen**

### **School Number: 2020202171**

### **Question 1:**
"""

#Run the original crawlWeb
def getPage(url):
  try:
    import urllib.request
    page = urllib.request.urlopen(url).read()
    page = page.decode("utf-8")
    return page
  except:
    print("Failed to get the page")
    return ""

def lookup(index, keyword):
  for entry in index:
    if entry[0] == keyword:
      return entry[1]
  return None

def getNextTarget(page):
    start_link = page.find('<a href=')
    if start_link == -1:
        return None, 0
    start_quote = page.find('"', start_link)
    end_quote = page.find('"', start_quote+1)
    url = page[start_quote + 1:end_quote]
    return url, end_quote

def getAllLinks(page):
    links = []
    while True:
      url, endpos = getNextTarget(page)
      if url:
        links.append(url)
        page = page[endpos:]
      else:
        break
    return links

def addToIndex(index, keyword, url):
  for entry in index:
    if entry[0] == keyword:
      entry[1].append(url)
      return
  index.append([keyword, [url]])

def addPageToIndex(index, url, content):
  words = content.split()
  for word in words:
    addToIndex(index, word, url)

def crawlWeb(seed):
  toCrawl = set([seed])
  crawled = set()
  index = {}
  graph = {}
  while toCrawl:
    page = toCrawl.pop()
    if page not in crawled:
      content = getPage(page)
      addPageToIndex(index, page, content)
      outlinks = getAllLinks(content)
      graph[page] = outlinks
      toCrawl.update(set(outlinks))
      crawled.add(page)
  return index, graph

def computeRanks(graph):
  d = 0.8
  N = len(graph)
  numloops = 10
  ranks = {}
  for page in graph:
    ranks[page] = 1/N
    for i in range(0, numloops):
      newranks = {}
      for page in graph:
        newrank = (1 - d) / N
        for node in graph:
          if page in graph[node]:
            newrank = newrank + d*(ranks[node]/len(graph[node]))
        newranks[page] = newrank
      ranks = newranks
  return ranks

#1-b: changing the index structure. Current index structure is for each element: [keyword,[url1,url2,...]]. Update the index structure as [keyword,[url1,url2,...,],# of links]

#the previous version of lookup function:
def lookup(index, keyword):
  for entry in index:
    if entry[0] == keyword:
      return entry[1]
  return None

#with the adjustments:
def lookup(index, keyword):
  if keyword in index:
    urls, number_of_links = index[keyword]
    print(f"Keyword: {keyword}")
    print(f"{number_of_links} result found.")
    print("Urls:")
    for url in urls:
      print(url)
    return urls
  return None

#I have written the lookup function according to the new version of the index. But I haven't changed the index structure yet.
#Here I will change the index structure by changing the addToIndex function:

#the previous version of addToIndex function:
def addToIndex(index, keyword, url):
  for entry in index:
    if entry[0] == keyword:
      entry[1].append(url)
      return
  index.append([keyword, [url]])

#with the adjustments: [keyword,[url1,url2,...,],# of links]
def addToIndex(index, keyword, url):
  if keyword in index:
      index[keyword][0].append(url)
      index[keyword][1] += 1
  else:
    index[keyword] = [[url], 1]

def getPage(url):
  try:
    import urllib.request
    page = urllib.request.urlopen(url).read()
    page = page.decode("utf-8")
    return page
  except:
    print("Failed to get the page")
    return ""

def lookup(index, keyword):
    if keyword in index:
        urls, count = index[keyword]
        print(f"Keyword: {keyword}")
        print(f"{count} result{'s' if count != 1 else ''} found.")
        print("Urls:")
        for url in urls:
            print(url)
    else:
        print(f"Keyword '{keyword}' not found in the index.")
    return None

def getNextTarget(page):
    start_link = page.find('<a href=')
    if start_link == -1:
        return None, 0
    start_quote = page.find('"', start_link)
    end_quote = page.find('"', start_quote+1)
    url = page[start_quote + 1:end_quote]
    return url, end_quote

def getAllLinks(page):
    links = []
    while True:
      url, endpos = getNextTarget(page)
      if url:
        links.append(url)
        page = page[endpos:]
      else:
        break
    return links

def addToIndex(index, keyword, url):
  if keyword in index:
      index[keyword][0].append(url)
      index[keyword][1] += 1
  else:
    index[keyword] = [[url], 1]

def addPageToIndex(index, url, content):
  words = content.split()
  for word in words:
    addToIndex(index, word, url)

def crawlWeb(seed):
  toCrawl = set([seed])
  crawled = set()
  index = {}
  graph = {}
  while toCrawl:
    page = toCrawl.pop()
    if page not in crawled:
      content = getPage(page)
      addPageToIndex(index, page, content)
      outlinks = getAllLinks(content)
      graph[page] = outlinks
      toCrawl.update(set(outlinks))
      crawled.add(page)
  return index, graph

def computeRanks(graph):
  d = 0.8
  N = len(graph)
  numloops = 10
  ranks = {}
  for page in graph:
    ranks[page] = 1/N
    for i in range(0, numloops):
      newranks = {}
      for page in graph:
        newrank = (1 - d) / N
        for node in graph:
          if page in graph[node]:
            newrank = newrank + d*(ranks[node]/len(graph[node]))
        newranks[page] = newrank
      ranks = newranks
  return ranks

index, graph = crawlWeb("https://searchengineplaces.com.tr/")
lookup(index, "its")

#1-c: changing the search method of lookup function. defining a new function called lookuplink. it will take a link as input and print all the keywords in the index that match this link and how many keyword are there.
def lookUpLink(index, link):
  matching_keywords = []
  for keyword in index:
    if link in index[keyword][0]:
      matching_keywords.append(keyword)
  print(f"Link: {link}")
  print(f"{len(matching_keywords)} keyword found.")
  for keyword in matching_keywords:
    print(keyword)

lookUpLink(index,"http://www.searchengineplaces.com.tr/oktayrecommends.html")

"""### **Question 2:**"""

def frequencyOfWord(text):
  text = text.lower() #converting the text to lowercase, so that it will not pay attention to lower-uppercase differences. And it will calculate the frequency correctly.
  no_punctuation = '' #initializing it as an empty string at the begining
  for char in text: #getting rid of the punctuation so that words with difference in the punctuation marks that are attached to them won't create inconsistency in word frequency.
    if char not in ".,;:'?!-_":
      no_punctuation += char
    else:
      no_punctuation += ''
  text = no_punctuation
  words = text.split() #we use split() to get the words from the text which is a string.
  word_frequency = {} #creating a dictionary which we will show the words and their frequency in the text given.
  print("Words:")
  for word in words:
    if word in word_frequency:
      word_frequency[word] += 1
    else:
      word_frequency[word] = 1
  return word_frequency

frequencyOfWord ("In programming , the hard part isn’t solving problems, but deciding what problems to solve .")

"""### **Question 3**"""

import math

class Rectangle(): #creating the class named rectangle.
  def __init__(self, width, height): #initiating two class attributes: width and height.
    self.width = width
    self.height = height

  def area(self):#1-a: defining a function named area within the class.
    return self.width*self.height

  def diagonal(self): #1-b: defining a function named diagonal within the class.
    return math.sqrt(self.width**2 + self.height**2)

  def __eq__(self, other): #1-c: overriding the eq method to write an operation that checks whether if two rectangles are equal and returns True or False.
    if type(self) == type(other):
      return {self.width, self.height} == {other.width, other.height}
    return False

  def __add__(self, other): #1-d:overriding the add method to add two rectangles. This function adds their lengths and widths separately and returns a new object with the rectangle class.
    if type(self) == type(other):
      new_height = self.height + other.height
      new_width = self.width + other.width
      return Rectangle(new_width, new_height)

  def __str__(self): #overriding the str method to print side lengths of the rectangle.
    return f'Rectangle with width {self.width} and height {self.height}'

rec1 = Rectangle (3 ,4)
rec2 = Rectangle (3 ,4)
rec3 = Rectangle (4 ,3)
rec4 = Rectangle (6 ,3)
print(rec1.area())
print(rec1.diagonal())

print(rec1==rec2)
print(rec2==rec3)
print(rec3==rec4)
rec5 = rec3 + rec4
print(rec5.width, rec5.height)
print(rec5)